# Headless Commerce Extensions

This project contains sample extension example for D365 Retail CRT & POS.

## Get Store Hours Sample
This extension is to get the store hours. Below are the sequence of objects created.
1. Created empty projects for ChannelDatabase, POS, Scale Unit installer and Commerce extensions.
2. Under Commerce extension folder, created a new project for CRT extension i.e. Runtime.Extension.StoreHours

	For CRT extensions
	1. Entity is created, which is basically the table structure we would like to get it from database.
	2. Request class is created, this constructs the request object based on the input parameters.
		Ex : For getting store hours, we would need store number primary input, hence we included it as parameter in class contructor. We can also add multiple input parameters 
			 based on the requirement, we can also pass recid, account Id, or list of records to process.
	3. Response class is created, response class is used for returning response object. We can take DB response as entity result and pass it to Response class.
	   In response class, based on the DB entity result, we can have multiple response methods. 
	   Even though DB returns many rows, we can chose to response only top 10, top 100, top 1000 etc.
	4. Data service class is created to handle business logic. In D365 architecture, service execute method is called based on supported request types.
	   Request class is used to get the input parameter for DB query execution/business logic process. 
	   Returns the reponse class after the execution.
	5. Controller class is created to call the specific API. API methods takes the input parameters and contructs the Request class.
	   Request is executed and response class is returned. Finally returns the result using the response class.

3. Create a Scale Unit Installer and deploy
    
	After creating required CRT extensions, we need to deploy the changes to Retail Server so that API's can be consumed in POS/POSTMAN/C#.
	Create a new Console Application project for Scale Unit, added a Scale Unit dependency. We need to add the Project dependency as below
	1. Scale Unit Nuget Dependency -> PackageReference Include="Microsoft.Dynamics.Commerce.Sdk.Installers.ScaleUnit" Version="$(CommerceSdkPackagesVersion)" 
	2. Project Dependency ->
		ProjectReference Include="..\..\..\Rajendra.Extensions\ChannelDatabase\ChannelDatabase.csproj" ReferenceOutputAssembly="false" 
		ProjectReference Include="..\..\..\Rajendra.Extensions\CommerceRuntime\Runtime.Extension.StoreHours\Runtime.Extension.StoreHours.csproj" ReferenceOutputAssembly="false" SkipGetTargetFrameworkProperties="true" 
		ProjectReference Include="..\..\..\Rajendra.Extensions\POS\POS.csproj" ReferenceOutputAssembly="false" SkipGetTargetFrameworkProperties="true"

	3. After building the Scale unit installer project, it will automatically create a new EXE file for CRT extension installer.
	4. Deploy the EXE and validate the custom CRT extension API's using retail server URL metadata.
	
4. Added sample Controller classes to return boolean values, string values.
5. Test from postman (Prerequisites are completed before API call, like Bearer Token).
   1. {{General_RetailServer}}/RetailServer/Commerce/RajendraEntityAPI/GetMyName?api-version=7.3z
   2. {{General_RetailServer}}/RetailServer/Commerce/RajSampleGet?api-version=7.3


----------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Commerce Proxy Generator

External applications can use the proxy to interact with Commerce APIs, the Commerce proxy 
abstracts the Commerce APIs and the Commerce runtime (CRT) entities, request and response and 
generates interfaces/metadata for the external application to consume the Commerce API and 
entities in an easier way, like metadata generated by the .NET framework for consuming the 
supported web services. For example, to consume the custom entities or the Commerce APIs in 
the external applications either you can use the metadata generated by proxy tool or you can 
manually create all the entities and request/response metadata in the client applications and 
manual creation involves lots of additional overhead, because you may need to maintain, update, 
and duplicate the entities, manager, and request/response code in two places.

The Commerce proxy reduces this effort by automatically generating the proxy for all the 
custom entities and request/response operations that are added in Commerce APIs. 
The proxy tool generates the required interface and all the required metadata and abstracts 
the actual implementation. In that way, you can include the files in the extension projects, 
and can access the Commerce APIs and the entities by using the metadata and interface that 
are generated.


1. Create a new project 'RajendraRetailServerExtensions' this has all the controller classes of 
all the extensions. This is one folder for all the controller classes. This folder is referenced in 
C# proxy generator project.
2. Create a new C# proxy project which generates proxies for all the retail server extensions.
3. Create a new TypeScript proxy project which generates proxies for all the retail server extensions.

Both Projects will have reference to 'RajendraRetailServerExtensions' which inturn have all the controllers classes and entities.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------